package substitution_test

import (
	"os/exec"
	"regexp"
	"testing"

	"github.com/bazelbuild/rules_go/go/runfiles"
	"gopkg.in/yaml.v3"
)

var (
	k8sObjRunfilePath string
)

// TestSubstitutionStamping checks if substitutions in the k8s_object output work correctly.
// It combines the logic of the two Python test methods.
func TestSubstitutionStamping(t *testing.T) {
	// Find the path to the executable generated by the k8s_object rule.
	k8sObjPath, err := runfiles.Rlocation(k8sObjRunfilePath)
	if err != nil {
		t.Fatalf("Failed to find runfile %q: %v", k8sObjRunfilePath, err)
	}

	// Execute the k8s_object script and capture its output.
	cmd := exec.Command(k8sObjPath)
	outBytes, err := cmd.Output() // Captures stdout, stderr goes to test runner's stderr
	if err != nil {
		// If the command fails, include stderr for debugging if available.
		stderr := ""
		if exitErr, ok := err.(*exec.ExitError); ok {
			stderr = string(exitErr.Stderr)
		}
		t.Fatalf("Failed to execute %q: %v\nStderr: %s", k8sObjPath, err, stderr)
	}

	// Parse the YAML output.
	// We use map[string]interface{} for flexibility, similar to yaml.safe_load.
	var generated map[string]interface{}
	if err := yaml.Unmarshal(outBytes, &generated); err != nil {
		t.Fatalf("Failed to unmarshal YAML output from %q: %v\nOutput:\n%s", k8sObjPath, err, string(outBytes))
	}

	// --- Assertions ---

	// Check for the 'data' field, expecting it to be a map.
	dataField, ok := generated["data"]
	if !ok {
		t.Fatalf("YAML output missing top-level 'data' key. Output:\n%s", string(outBytes))
	}
	dataMap, ok := dataField.(map[string]interface{})
	if !ok {
		t.Fatalf("'data' field is not a map (type %T). Output:\n%s", dataField, string(outBytes))
	}

	// 1. Test %{e2e_namespace} substitution (stamping)
	t.Run("E2ENamespaceSubstituted", func(t *testing.T) {
		nsValue, ok := dataMap["e2e_namespace"]
		if !ok {
			t.Errorf("Missing 'data.e2e_namespace' key in YAML output.")
			return // No point checking value if key is missing
		}
		nsStr, ok := nsValue.(string)
		if !ok {
			t.Errorf("Expected 'data.e2e_namespace' to be a string, but got %T.", nsValue)
			return
		}

		// Regex ported from assertRegexpMatches
		matched, err := regexp.MatchString(`^build-.+$`, nsStr)
		if err != nil {
			// Should not happen with a valid regex
			t.Fatalf("Internal test error: regex compilation failed: %v", err)
		}
		if !matched {
			t.Errorf("Value for 'data.e2e_namespace' (%q) did not match expected pattern %q", nsStr, `^build-.+$`)
		}
	})

	// 2. Test %{key} substitution (fixed value)
	t.Run("KeySubstituted", func(t *testing.T) {
		fooValue, ok := dataMap["foo"]
		if !ok {
			t.Errorf("Missing 'data.foo' key in YAML output.")
			return
		}
		fooStr, ok := fooValue.(string)
		if !ok {
			t.Errorf("Expected 'data.foo' to be a string, but got %T.", fooValue)
			return
		}

		expectedFoo := "bar"
		if fooStr != expectedFoo {
			t.Errorf("Value for 'data.foo' was %q, expected %q", fooStr, expectedFoo)
		}
	})
}

// Helper function to access nested map values safely (optional but good practice)
// Example Usage: value, ok := getNestedString(generated, "data", "e2e_namespace")
func getNestedString(data map[string]interface{}, keys ...string) (string, bool) {
	var current interface{} = data
	for i, key := range keys {
		mapCurrent, ok := current.(map[string]interface{})
		if !ok {
			return "", false // Parent was not a map
		}
		value, exists := mapCurrent[key]
		if !exists {
			return "", false // Key doesn't exist at this level
		}
		if i == len(keys)-1 {
			// This is the final key, check if it's a string
			strValue, ok := value.(string)
			return strValue, ok
		}
		// It's an intermediate key, continue traversal
		current = value
	}
	// Should not be reached if keys has elements
	return "", false
}
